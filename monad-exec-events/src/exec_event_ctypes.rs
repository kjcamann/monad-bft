// Copyright (C) 2025 Category Labs, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
//    util/ctypes/codegen/cg-ctypes -s category/execution/ctypes/v1 rust -p
//    /home/ken/src/monad-bft/monad-exec-events/src -frustfmt +nightly

//! Definitions of event payloads used with the EXEC event ring

#![allow(non_camel_case_types)]
#![allow(unused_imports)]

use alloy_primitives::{Address, B256, U256};
use monad_event_ring::{event_metadata::*, event_ring::monad_event_record_error};

use crate::{eth_ctypes::*, monad_ctypes::*};

/// Each type of event is assigned a unique value in this enumeration
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
#[repr(u16)]
pub enum exec_event_type {
    #[default]
    NONE,
    RECORD_ERROR,
    BLOCK_START,
    BLOCK_REJECT,
    BLOCK_PERF_EVM_ENTER,
    BLOCK_PERF_EVM_EXIT,
    BLOCK_END,
    BLOCK_QC,
    BLOCK_FINALIZED,
    BLOCK_VERIFIED,
    TXN_HEADER_START,
    TXN_ACCESS_LIST_ENTRY,
    TXN_AUTH_LIST_ENTRY,
    TXN_HEADER_END,
    TXN_REJECT,
    TXN_PERF_EVM_ENTER,
    TXN_PERF_EVM_EXIT,
    TXN_EVM_OUTPUT,
    TXN_LOG,
    TXN_CALL_FRAME,
    TXN_END,
    ACCOUNT_ACCESS_LIST_HEADER,
    ACCOUNT_ACCESS,
    STORAGE_ACCESS,
    EVM_ERROR,
}

/// Reserved event type used for recording errors
pub type record_error = monad_event_record_error;

/// Stored in event descriptor's `content_ext` array to tag the block &
/// transaction context of event
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
#[repr(u8)]
pub enum flow_type {
    #[default]
    BLOCK_SEQNO,
    TXN_ID,
    ACCOUNT_INDEX,
}

/// Identifies a unique block that has been proposed by the consensus algorithm;
/// used to refer to a block before it is finalized.
///
/// The information in this "tag" object is used to track a block as it is
/// operated on by the consensus algorithm. The (not yet unique) `block_number`
/// is the number the block _will_ have, if it eventually gets finalized. The
/// `id` field uniquely identifies the block contents, vs. all the other
/// proposals of different blocks to become the same `block_number`. `id` can be
/// used to track this specific block before finalization.
///
/// For more information on this, see [here](https://docs.monad.xyz/monad-
/// arch/realtime-data/spec-realtime) for details
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_tag {
    pub id: B256,          // Monad consensus unique ID for block
    pub block_number: u64, // Proposal is to become this block
}

/// Event recorded at the start of EVM execution
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_start {
    pub block_tag: block_tag,                  // Proposal is for this block
    pub round: u64,                            // Round when block was proposed
    pub epoch: u64,                            // Epoch when block was proposed
    pub proposal_epoch_nanos: u128,            // UNIX epoch nanosecond timestamp
    pub chain_id: U256,                        // Blockchain we're associated with
    pub author: secp256k1_pubkey,              // Public key of block author
    pub parent_eth_hash: B256,                 // Hash of Ethereum parent block
    pub eth_block_input: eth_block_input,      // Ethereum execution inputs
    pub monad_block_input: native_block_input, // Monad execution inputs
}

/// Event recorded when a block is rejected (i.e., is invalid)
///
/// This corresponds to a value in the `BlockError` enumeration in
/// `validate_block.hpp`, in the execution repo source code.
pub type block_reject = u32;

/// Event recorded upon successful block execution
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_end {
    pub eth_block_hash: B256,               // Hash of Ethereum block
    pub exec_output: eth_block_exec_output, // Ethereum execution outputs
}

/// Event recorded when a proposed block obtains a quorum certificate
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_qc {
    pub block_tag: block_tag, // QC for proposal with this block
    pub round: u64,           // Round of proposal vote
    pub epoch: u64,           // Epoch of proposal vote
}

/// Event recorded when consensus finalizes a block
pub type block_finalized = block_tag;

/// Event recorded when consensus verifies the state root of a finalized block
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_verified {
    pub block_number: u64, // Number of verified block
}

/// First event recorded when transaction processing starts
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_header_start {
    pub txn_hash: B256,             // Keccak hash of transaction RLP
    pub sender: Address,            // Recovered sender address
    pub txn_header: eth_txn_header, // Transaction header
}

/// Entry in an EIP-2930 storage access warmup list
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_access_list_entry {
    pub index: u32,               // Array index of access list entry
    pub entry: access_list_entry, // Entry for a single account
}

/// Entry in an EIP-7702 authorization list
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_auth_list_entry {
    pub index: u32,               // Array index of EIP-7702 list entry
    pub entry: auth_list_entry,   // Entry for a single authorization
    pub authority: Address,       // Recovered authority from signature
    pub is_valid_authority: bool, // Distinguish true 0x0 from recovery failure
}

/// Event recorded when a transaction is rejected (i.e., is invalid)
///
/// This corresponds to a value in the `TransactionError` enumeration in
/// `validate_transaction.hpp`, in the execution repo source code.
pub type txn_reject = u32;

/// Event recorded when transaction execution halts.
///
/// This is a "header" event: it appears before all other transaction output
/// events, namely all the TXN_LOG and TXN_CALL_FRAME events associated with
/// this transaction. It is emitted first, to announces the total number of log
/// and call frame events that the reader should expect. After all transaction
/// are emitted, an ACCOUNT_ACCESS_LIST_HEADER event with transaction scope will
/// be emitted, announcing all state change accesses in the scope of this
/// transaction.
///
/// Once all execution outputs have been emitted for a particular transaction
/// number, a TXN_END event will be emitted to mark the end of all that
/// transaction's events.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_evm_output {
    pub receipt: eth_txn_receipt, // Incremental Ethereum receipt
    pub call_frame_count: u32,    // Number of call frames
}

/// Event recorded when a transaction emits a LOG
pub type txn_log = eth_txn_log;

/// Event recorded when a call frame is emitted.
///
/// Trace information about an execution context that was created during an EVM
/// contract invocation ("call"), or contract creation.
///
/// Formally, the EVM operates through concepts called 'message calls' and
/// 'contract creations'. Each of these defines an execution environment, which
/// contains data such as the account causing the code to execute. A formal list
/// of all the items in the environment is part of the official specification.
///
/// Each call (and contract creation) gets its own environment. The environments
/// are set up in different ways, depending on how the call occurs (e.g., a CALL
/// vs. DELEGATECALL opcode). A call frame is a summary of the inputs and
/// outputs to an execution environment, whether the halting was normal or
/// exceptional, and other information useful for tracing the call tree.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_call_frame {
    pub index: u32,           // Array index of call frame
    pub caller: Address,      // Address initiating call
    pub call_target: Address, // Address receiving call (or deployment addr)
    pub opcode: u8,           // EVM opcode that creates frame
    pub value: U256,          // I_v: value passed to account during execution
    pub gas: u64,             // g: gas available for message execution
    pub gas_used: u64,        // Gas used by call
    pub evmc_status: i32,     // evmc_status_code of call
    pub depth: u64,           // I_e: depth of call context stack
    pub input_length: u64,    // Length of trailing call input
    pub return_length: u64,   // Length of trailing return data
}

/// Context in which EVM accessed / modified an account
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
#[repr(u8)]
pub enum account_access_context {
    #[default]
    BLOCK_PROLOGUE,
    TRANSACTION,
    BLOCK_EPILOGUE,
}

/// Header event that precedes a variably-sized list of account_access objects
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct account_access_list_header {
    pub entry_count: u32, // Number of account_access_entry events
    pub access_context: account_access_context, // Context of account accesses
}

/// Event emitted when an account is read or written
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct account_access {
    pub index: u32,                             // Index in accessed account list
    pub address: Address,                       // Address of account
    pub access_context: account_access_context, // Context of account access
    pub is_balance_modified: bool,              // True -> modified_balance meaningful
    pub is_nonce_modified: bool,                // True -> modified_nonce meaningful
    pub prestate: eth_account_state,            // Read (or original) balance
    pub modified_balance: U256,                 // New balance, if modified
    pub modified_nonce: u64,                    // New nonce, if modified
    pub storage_key_count: u32,                 // Number of trailing storage_access events
    pub transient_count: u32,                   // As above, but for transient storage
}

/// Event emitted for each account storage key that is accessed
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct storage_access {
    pub address: Address,                       // Address of storage account
    pub index: u32,                             // Index of storage records in this context
    pub access_context: account_access_context, // Context of account access
    pub modified: bool,                         // True -> new_value meaningful
    pub transient: bool,                        // True -> is transient storage
    pub key: B256,                              // Storage key accessed / modified
    pub start_value: B256,                      // Read (or original) value
    pub end_value: B256,                        // New value, if modified
}

/// Error occurred in execution process (not a validation error)
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct evm_error {
    pub domain_id: u64,   // Boost.Outcome domain id of error
    pub status_code: i64, // Boost.Outcome status code of error
}

pub fn format_as(bytes: &[u8], event_type: exec_event_type) -> String {
    match event_type {
        exec_event_type::RECORD_ERROR => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const record_error) })
        }
        exec_event_type::BLOCK_START => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_start) })
        }
        exec_event_type::BLOCK_REJECT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_reject) })
        }
        exec_event_type::BLOCK_END => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_end) })
        }
        exec_event_type::BLOCK_QC => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_qc) })
        }
        exec_event_type::BLOCK_FINALIZED => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const block_finalized)
        }),
        exec_event_type::BLOCK_VERIFIED => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const block_verified)
        }),
        exec_event_type::TXN_HEADER_START => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const txn_header_start)
        }),
        exec_event_type::TXN_ACCESS_LIST_ENTRY => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const txn_access_list_entry)
        }),
        exec_event_type::TXN_AUTH_LIST_ENTRY => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const txn_auth_list_entry)
        }),
        exec_event_type::TXN_REJECT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_reject) })
        }
        exec_event_type::TXN_EVM_OUTPUT => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const txn_evm_output)
        }),
        exec_event_type::TXN_LOG => format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_log) }),
        exec_event_type::TXN_CALL_FRAME => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const txn_call_frame)
        }),
        exec_event_type::ACCOUNT_ACCESS_LIST_HEADER => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const account_access_list_header)
        }),
        exec_event_type::ACCOUNT_ACCESS => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const account_access)
        }),
        exec_event_type::STORAGE_ACCESS => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const storage_access)
        }),
        exec_event_type::EVM_ERROR => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const evm_error) })
        }
        _ => String::new(),
    }
}

pub const EXEC_EVENT_COUNT: usize = 25;
pub const EXEC_EVENT_METADATA: [EventMetadata; EXEC_EVENT_COUNT] = [

    EventMetadata {
        event_type: exec_event_type::NONE as u16,
        c_name: "NONE",
        description: "Reserved code so that 0 remains invalid",
    },

    EventMetadata {
        event_type: exec_event_type::RECORD_ERROR as u16,
        c_name: "RECORD_ERROR",
        description: "Reserved event type used for recording errors",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_START as u16,
        c_name: "BLOCK_START",
        description: "Event recorded at the start of EVM execution",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_REJECT as u16,
        c_name: "BLOCK_REJECT",
        description: "Event recorded when a block is rejected (i.e., is invalid)",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_PERF_EVM_ENTER as u16,
        c_name: "BLOCK_PERF_EVM_ENTER",
        description: "Performance marker event recorded at the start of core EVM execution (after validation and sender recovery)",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_PERF_EVM_EXIT as u16,
        c_name: "BLOCK_PERF_EVM_EXIT",
        description: "Performance marker event recorded when all transaction execution is finished",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_END as u16,
        c_name: "BLOCK_END",
        description: "Event recorded upon successful block execution",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_QC as u16,
        c_name: "BLOCK_QC",
        description: "Event recorded when a proposed block obtains a quorum certificate",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_FINALIZED as u16,
        c_name: "BLOCK_FINALIZED",
        description: "Event recorded when consensus finalizes a block",
    },

    EventMetadata {
        event_type: exec_event_type::BLOCK_VERIFIED as u16,
        c_name: "BLOCK_VERIFIED",
        description: "Event recorded when consensus verifies the state root of a finalized block",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_HEADER_START as u16,
        c_name: "TXN_HEADER_START",
        description: "First event recorded when transaction processing starts",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_ACCESS_LIST_ENTRY as u16,
        c_name: "TXN_ACCESS_LIST_ENTRY",
        description: "Entry in an EIP-2930 storage access warmup list",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_AUTH_LIST_ENTRY as u16,
        c_name: "TXN_AUTH_LIST_ENTRY",
        description: "Entry in an EIP-7702 authorization list",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_HEADER_END as u16,
        c_name: "TXN_HEADER_END",
        description: "Marker event recorded after all transaction header events are emitted",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_REJECT as u16,
        c_name: "TXN_REJECT",
        description: "Event recorded when a transaction is rejected (i.e., is invalid)",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_PERF_EVM_ENTER as u16,
        c_name: "TXN_PERF_EVM_ENTER",
        description: "Performance marker event recorded at the start of EVM execution (after sender recovery)",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_PERF_EVM_EXIT as u16,
        c_name: "TXN_PERF_EVM_EXIT",
        description: "Performance marker event recorded at the end of EVM execution",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_EVM_OUTPUT as u16,
        c_name: "TXN_EVM_OUTPUT",
        description: "Event recorded when transaction execution halts.",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_LOG as u16,
        c_name: "TXN_LOG",
        description: "Event recorded when a transaction emits a LOG",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_CALL_FRAME as u16,
        c_name: "TXN_CALL_FRAME",
        description: "Event recorded when a call frame is emitted.",
    },

    EventMetadata {
        event_type: exec_event_type::TXN_END as u16,
        c_name: "TXN_END",
        description: "Event recorded to mark the end of events for this transaction",
    },

    EventMetadata {
        event_type: exec_event_type::ACCOUNT_ACCESS_LIST_HEADER as u16,
        c_name: "ACCOUNT_ACCESS_LIST_HEADER",
        description: "Header event that precedes a variably-sized list of account_access objects",
    },

    EventMetadata {
        event_type: exec_event_type::ACCOUNT_ACCESS as u16,
        c_name: "ACCOUNT_ACCESS",
        description: "Event emitted when an account is read or written",
    },

    EventMetadata {
        event_type: exec_event_type::STORAGE_ACCESS as u16,
        c_name: "STORAGE_ACCESS",
        description: "Event emitted for each account storage key that is accessed",
    },

    EventMetadata {
        event_type: exec_event_type::EVM_ERROR as u16,
        c_name: "EVM_ERROR",
        description: "Error occurred in execution process (not a validation error)",
    },
];

pub static EXEC_EVENT_DOMAIN_METADATA: EventDomainMetadata = EventDomainMetadata {
    schema_hash: [
        0x89, 0x33, 0xf9, 0x7, 0xc4, 0x32, 0xc9, 0x8a, 0xc0, 0xc8, 0xdb, 0x62, 0xf9, 0xaa, 0x16,
        0x4c, 0xc, 0x3f, 0x16, 0x72, 0xf4, 0x12, 0x90, 0xe4, 0xea, 0x34, 0x8, 0xdf, 0x6c, 0x67,
        0x23, 0xf3,
    ],
    events: &EXEC_EVENT_METADATA,
};

pub const EXEC_EVENT_DEFAULT_FILE_NAME: &str = "monad-exec-events";
